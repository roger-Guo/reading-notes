# 三维世界
* __`视点`__ 观察者所处的位置
* __`视线`__ 从试点沿着观察方向的射线
* __`观察目标点`__ 目标所在的点
* __`上方向`__ 最终绘制在屏幕上的影像中的向上的方向，没有上方向，观察者可以以视线为轴旋转，这样观察到的场景也会偏移
## __`视图矩阵`__ 视图矩阵表示观察者的状态，含有观察者的视点，观察目标点，上方向等信息。之所以称为视图矩阵，是因为他最终影响了显示在屏幕上的视图，也就是观察者的场景。 默认的视点(0, 0, 0)，视线为Z轴负方向，观察点为(0, 0, -1)，上方向为Y轴正方向(0, 1, 0).
#### 实际上，"根据自定义的观察者状态，绘制观察者看到的景象"与"使用默认的观察状态，但是与三维对象进行平移、旋转等变换，再绘制观察者看到的景象"，这两种行为是等价的。默认的观察状态就是在原点，视线沿Z轴负方向观察。视图矩阵没有越远越小的概念。
* __`视点`__ 控制X轴、Y轴、Z轴方向的平移
* __`观察点`__ 控制X轴、Y轴、Z轴方向的平移
* __`上方向`__ 控制旋转
## __`模型矩阵`__ 平移、旋转、缩放等基本矩阵或他们的组合。
* __`<视图矩阵> * <模型矩阵> * <原始顶点坐标>`__ 要想旋转图形，就需要用旋转矩阵乘以旋转前的顶点坐标，在用视图矩阵乘以旋转以后的顶点坐标就能获得"从视点看上去"的旋转之后的顶点坐标
## __`可视范围`__ 实际得到的范围区域边界
## __`可视空间`__ 包括水平视角、垂直视角、可视深度
#### __`正射投影`__ 长方体可视空间，也称盒装空间。
* __`Matrix4.setOrtho(left, right, bottom, top, near, far)`__
  * right - left 表示canvas的宽 超出部分就不见了
  * top - bottom 表示canvas的高 超出部分就不见了
* __`<正射投影矩阵> * <视图矩阵> * <原始顶点坐标>`__
#### __`透视投影`__ 四棱锥可视空间。
* __`Matrix4.setPerspective(fov, aspect, near, far)`__
  * __`fov`__ 垂直视角，即可视空间顶面与地面的夹角，必须大于0
  * __`aspect`__ 指定近裁剪面的宽高比 这个参数值应该与canvas宽高比保持一致。
  * __`near far`__ 近裁剪面与远裁剪面相对于 __`视点`__ 的位置。都必须大于
## 矩阵为什么可以定义可视空间？
* 实际上，透视投影矩阵对三角形进行了两次变换。这表明可视空间的规范可以用一系列基本变换来定义。Matrix4对象的setPerspective()方法自动的根据上述可视空间的参数计算出对应的变换矩阵。
  * 根据三角形与视点的距离，按比例对三角形进行了缩小变换
  * 对三角形进行平移变换，使其贴近视线。
* __`<投影矩阵> * <视图矩阵> * <模型矩阵> * <原始顶点坐标>`__
## 正确处理对象的前后关系
### WebGL在默认情况下会按照缓冲区中的顺序绘制图形，而且后绘制的图形覆盖绘制的图形，因为这样做很高效。
#### __`隐藏面消除`__ 这个功能会让远处的物体自动的被近处的物体挡住，不会被绘制出来。
#### __`深度缓冲区`__ 要将隐藏面消除，那就必须知道每个几何图形的深度信息，而深度缓冲区就是用来存储深度信息的。由于深度方向通常是Z轴方向，所以有时候我们也称他为Z缓冲区。
```GLSL ES
  gl.enable(gl.DEPTH_TEST); // 开启隐藏面消除功能
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 同时清除深度缓冲区和颜色缓冲区
```
### __`深度缓冲`__ 当几何体表面极为接近时，就会出现新的问题，表面看上去斑斑驳驳。因为深度缓冲区有限的精度已经不能区分那个在前那个在后。
#### __`多边形偏移`__ 改机制自动在Z值上加一个偏移量，偏移量的值由物体表面相对于观察者的角度来确定。
```GLSL ES
  gl.polygonOffset(1.0, 1.0); // 设置多边形偏移
```
## 立方体
#### __`gl.drawElements()`__ 使用该函数替代gl.drawArray()进行绘制，能够避免定义顶点重复的问题

## 模型矩阵对真实世界坐标进行平移，旋转，缩放等操作；视图矩阵设置观察者所在的视点，物体所在的观察点，以及上方向。改变这些值，物体不会动(真实世界坐标不会改变)，但是页面上物体会运动，因为从不同的角度看到了物体；投影矩阵则是相对于视点设置一个可视空间，在可视空间范围内，物体就能显示，否则会消失，这个矩阵也是对物体进行平移，缩放等操作，让远处的物体越来越小。但是实际上物体的世界坐标却没有改变。越来越小只是为了呈现出一种效果。等用户走进了物体，物体就会越来越大。