## RegExp
### 构造函数创建了一个正则表达式对象，用于将文本与一个  __模式匹配__ 。
```
  /pattern/flags
  new RegExp(pattern [, flags])
  RegExp(pattern [, flags])
```
#### pattern
##### 正则表达式的文本。
#### flags
* __` g `__ 全局匹配;找到所有匹配，而不是在第一个匹配后停止
* __` i `__ 忽略大小写
* __` m `__ 多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。
* __` u `__ Unicode; 将模式视为Unicode序列点的序列 (一个汉字的长度是1)
  * __`BMP字符`__ 一个UTF-16编码单位表示的字符 (一个汉字的length是2)
  * __`辅助平面字符`__ 两个UTF-16编码单位表示的字符 (一个汉字的length是1)
* __` y `__ 粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)。
#### RegExp实例属性
* __`RegExp.prototype.global`__ 是否开启全局匹配模式，也就是匹配目标字符串中所有可能的匹配项，而不是只进行第一次匹配。
* __`RegExp.prototype.ignoreCase`__ 在匹配字符串时是否要忽略大小写
* __`RegExp.prototype.lastIndex`__ 下次匹配开始的字符串索引位置
* __`RegExp.prototype.multiline`__ 是否开启多行模式匹配（影响 ^ 和 $ 的行为）。
* __`RegExp.prototype.sticky`__ 是否开启粘滞匹配。
* __`RegExp.prototype.source`__ 正则对象的源模式文本
#### RegExp构造函数属性
##### 这些属性在其他语言被看成静态属性。这些属性适用于 __作用域中所有的正则表达式__ ，并且基于最近一次正则表达式操作而变化。
* __`RegExp.input`__ 最近一次要匹配的字符串
* __`RegExp.lastMatch`__ 最近一次的匹配项
* __`RegExp.lastParen`__ 最近一次匹配的捕获组
* __`RegExp.leftContext`__ input字符串中lastMatch之前的文本
* __`RegExp.rightContext`__ input字符串中lastMatch之后的文本
* __`RegExp.$1……RegExp.$9`__ 用于存储第一、第二……第九个匹配的捕获组
#### RegExp实例方法
* __`RegExp.prototype.exec()`__ 在目标字符串中执行一次正则匹配操作
  * __`匹配成功返回值`__ 返回一个数组，并更新正则表达式对象的属性。返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面。
  * __`匹配失败返回值`__ null
* __`RegExp.prototype.text()`__ 测试当前正则是否匹配目标字符串
### 正则表达式中特殊字符的含义
#### 字符类别
* __`.`__ 匹配任意单个字符，但是行结束符除外：__`\n`__ __`\r`__ __`\u2028`__ 或 __`\u2029`__。
* __`\d`__ 匹配任意阿拉伯数字。等价于[0-9]。
* __`\D`__ 匹配任意一个不是阿拉伯数字的字符。等价于[^0-9]。
* __`\w`__ 匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线。等价于 [A-Za-z0-9_]。
* __`\W`__ 匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。等价于 [^A-Za-z0-9_]。
* __`\s`__ 匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。等价于 [ \f\n\r\t\v​\u00a0\u1680​\u180e\u2000​\u2001\u2002​\u2003\u2004​ \u2005\u2006​\u2007\u2008​\u2009\u200a​\u2028\u2029​​\u202f\u205f​ \u3000]。
* __`\S`__ 匹配一个非空白符
* __`\t`__ 匹配一个水平制表符（tab）
* __`\r`__ 匹配一个回车符
* __`\n`__ 匹配一个换行符
* __`\v`__ 匹配一个垂直制表符
* __`\f`__ 匹配一个换页符
* __`[\b]`__ 匹配一个退格符（backspace）（不要与 \b 混淆）
* __`\cX`__ X 是 A - Z 的一个字母。匹配字符串中的一个控制字符。例如，/\cM/ 匹配字符串中的 control-M。
* __`\xhh`__ 匹配编码为 hh （两个十六进制数字）的字符。
* __`\uhhhh`__ 匹配 Unicode 值为hhhh（四个十六进制数字）的字符。
#### 字符集合
* __`[xyz]`__ 一个字符集合，也叫字符组。匹配集合中的任意一个字符。你可以使用连字符'-'指定一个范围。
* __`[^xyz]`__ 它匹配任意不在括号内的字符。你也可以通过使用连字符 '-' 指定一个范围内的字符。
#### 边界
* __`^`__ 匹配输入开始
* __`$`__ 匹配输入结尾
* __`\b`__ 匹配一个零宽单词边界 /\bno/ 匹配 "at noon" 中的 "no"
* __`\B`__ 匹配一个零宽非单词边界 /\Bon/ 匹配 "at noon" 中的 "on"
#### 分组（Grouping）与反向引用（back references）
* __`(x)`__ 匹配 x 并且捕获匹配项。 这被称为捕获括号
* __`\n`__ n 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。例如，/apple(,)\sorange\1/ 匹配 "apple, orange, cherry, peach." 中的 "apple,orange,"。
* __`(?:x)`__ 匹配 x 不会捕获匹配项
#### 数量词
* __`x*`__ 匹配前面的模式 x 零次或多次。
* __`x+`__ 匹配前面的模式 x 1 或多次。等价于 {1,}。
* __`x*?`__ __`x+?`__ 像上面的 * 和 + 一样匹配前面的模式 x，然而匹配是最小可能匹配。/".*?"/ 匹配 '"foo" "bar"' 中的 '"foo"'，而 * 后面没有 ? 时匹配 '"foo" "bar"'。
* __`x?`__ 匹配前面的模式 x 零次或 1 次。
* __`x(?=y)`__ 只有当 x 后面紧跟着 y 时，才匹配 x。y不是匹配结果的一部分。
* __`x(?!y)`__ 只有当 x 后面不是紧跟着 y 时，才匹配 x。y不是匹配结果的一部分。
* __`x|y`__ 匹配 x 或 y /green|red/ 匹配 "green apple" 中的 ‘green'，"red apple." 中的 'red'。
* __`x{n}`__ n 是一个正整数。前面的模式 x 连续出现 n 次时匹配。
* __`x{n,}`__ n 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。
* __`x{n,m}	`__ n 和 m 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。
